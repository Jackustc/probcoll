# contains all needed parameters for all files

random_seed: 0
exp_dir: '/home/adam/probcoll/experiments/rccar'
exp_dir_car: '/home/ubuntu/probcoll/experiments/rccar'
exp_name: 'testing'

##########################
### Probcoll algorithm ###
##########################

probcoll:
  dt: 0.25
  T: 16  # timesteps per trajectory
  logger: 'info' # debug/info/fatal what level to log
  max_iter: 31
  label_with_noise: True # if false, saves desired controls (i.e. without control_noise)
  save_O: True

  # Training
  training_start_iter: 0
  is_training: True # EXPERIMENTAL
  asynchronous_training: False # EXPERIMENTAL

  # Conditions
  num_timesteps: 120

  testing:
    num_rollout: 20
    itr_freq: 2

######################
### Probcoll model ###
######################
    
model:
  T: 8 # how many timesteps to predict
  logger: 'info' # debug/info/warning/fatal what level to log
  save_checkpoints: 'last'

  # What to use as input to prediction model
  U_order: ['cmd_steer', 'cmd_vel']
  O_im_order: ['camera'] # 'camera' / 'back_camera'
  O_vec_order: []
  output_order: ['collision'] # taken from observations O
  num_O: 4

  # Normalize input  
  center_O_im: False 
  control_range:
    lower: [-45., -4.]
    upper: [ 45.,  4.]
  
  # Device
  device: 0
  gpu_fraction: 0.4
  num_reading_threads: 4

  # Optimization
  learning_rate: 1.e-4
  grad_clip: 10.0 # Norm gradient clip
  beta1: 0.9 # For ADAM
  beta2: 0.999 # For ADAM
  batch_size: 32
  pct_coll: 0.5 # rebalancing trajectories
  coll_weight_pct: 0.5 # reweight collision and no collision samples in cost
  reg: 1.e-8 # L2 regularization
  
  # Train schedule
#  steps: 2500
#  reset_freq: 4 # 0 means no resetting
  ckpt_after_step:  10000
  reset_after_step: 20000  
#  reset_steps: 10000
  display_steps: 100 
  val_pct: 0.1 # Percent of the data stored as validation
  val_steps: 10  # How many steps you do on validation 
  val_dropout: True # Whether you use dropout during validation

  # Model architecture
  dtype: 'float32' # only float32 is currently implemented
  data_format: 'NCHW'
  num_bootstrap: 1 # EXPERIMENTAL
  prob_coll_strictly_increasing: True # True / False 
  mask: 'all' # all / last

  image_graph:
    graph_type: 'cnn'
    filters: [32, 64, 64]
    kernels: [8, 4, 3]
    strides: [4, 2, 1]
    padding: 'SAME' 
    conv_activation: 'relu'
    output_activation: 'relu' # relu / tanh/ spatial_softmax 
#    normalizer: 'batch_norm'
    batch_norm_decay: 0.9
  
  observation_graph:
    hidden_layers: [256]
    hidden_activation: 'relu'
    output_dim: 128 # This is the hidden size of the rnn
    output_activation: 'relu'
#    normalizer: 'batch_norm'
    batch_norm_decay: 0.9

  action_graph:
    hidden_layers: [16]
    hidden_activation: 'relu'
    output_dim: 16
    output_activation: 'relu'
#    normalizer: 'batch_norm'
    batch_norm_decay: 0.9

  rnn_graph:
    graph_type: 'rnn'
    num_cells: 1
    cell_type: 'mulint_lstm' # rnn / mulint_rnn / lstm / mulint_lstm
#    dropout: 0.8 # pct keep
    cell_args: # If you need to pass variables to cells 
      use_layer_norm: False

  output_graph: 
    hidden_layers: [16]
    hidden_activation: 'relu'
#    normalizer: 'batch_norm'
    batch_norm_decay: 0.9
 
#################################################
### Planning objective and optimizer settings ###
################################################

planning:
  cost:
    coll_cost:
      cost: square # square
      weight: [0., 1.] 
      std_weight: 0.0 # EXPERIMENTAL
      pre_activation: True # EXPERIMENTAL wether std is before or after activation (sigmoid)
    
    control_cost:
      des: [0., 2.] # TODO: hard-coded order: steering then speed
      cost: square # square
      weight: [0., 1.]     

  # Planner
  planner_type: 'random' # random / cem / random_policy
  num_dp: 1 # number of dropout passes to average over during planning
  # control range for your planning algorithms
  control_range:
    lower: [-45.,  2.0]
    upper: [ 45.,  2.0]

  random:
    K: 1024 # number of actions to sample from

  cem:
    init_M: 2048 # number of actions to sample from
    M: 256
    K: 16 # top actions you select
    num_additional_iters: 3 # does not include first sample    
    warm_start:
      init_M: 1024 # number of actions to sample from
      M: 256
      K: 16 # top actions you select
      num_additional_iters: 1 # does not include first sample    
    eps: 0.01 # to ensure covariance is PD

  # Noise / exploration
  epsilon_greedy:
    control_range:
      lower: [-45.,  2.0]
      upper: [ 45.,  2.0]
    endpoints: [[0, 1.0], [2400, 0.1], [3600, 0.01]]
    outside_value: 0.0

  control_noise:
    endpoints: [[0, 1.0],  [2400, 0.1], [3600, 0.01]]
    outside_value: 0.0

    type: 'gaussian' # zero / gaussian / uniform
    zero: {}
    gaussian:
      std: [25.0, 0.0]
    uniform:
      lower: [-5., 0.]
      upper: [5., 0.]
  
  # Visualization
  visualize: False # EXPERIMENTAL
  topics:
    debug_cost: 'debug_cost' # visualization_msgs/MarkerArray
    debug_cost_probcoll: 'debug_cost_probcoll' # visualization_msgs/MarkerArray
  
###################
### Environment ###
###################

env:
  use_vel: True
  do_back_up: False
  max_time_step: 16
  dt: 0.25
  check_rollouts: True
  back_up:
    steer: [-5., 5.]
    vel: -1.
    duration: 3.0

######################################################
########### States, controls, observations ###########
######################################################

X:
  dim: 2
  order: ['velocity', 'collision']

  velocity: {idx: 0, dim: 1}
  collision: {idx: 1, dim: 1, buffer: 0.0}
U:
  dim: 2
  order: ['cmd_steer', 'cmd_vel']

  cmd_steer: {idx: 0, dim: 1}
  cmd_vel: {idx: 1, dim: 1}

O:
  dim: 2305
  order: ['camera', 'collision']

  camera:
    idx: 0
    dim: 2304
    height: 64
    width: 36
    num_channels: 1
  collision: {idx: 2304, dim: 1, buffer: 0.0}
